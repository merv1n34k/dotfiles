/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FocusActiveSentencePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// editorExtension.ts
var import_view = require("@codemirror/view");
function textStartsWithTitle(lineText, titles, i) {
  let foundTitle = false;
  for (const title of titles) {
    if (lineText.slice(i + 1 - title.length, i + 1) === title) {
      foundTitle = true;
      break;
    }
  }
  return foundTitle;
}
function getActiveSentenceBounds(line, pos) {
  const plugin = window.app.plugins.plugins["focus-active-sentence"];
  const sentenceDelimiters = plugin.settings.sentenceDelimiters.split("");
  const extraCharacters = plugin.settings.extraCharacters.split("");
  const titles = plugin.settings.titles.split("\n");
  const lineStart = line.from;
  const lineText = line.text;
  let start = -1;
  for (let i = pos - lineStart - 1; i >= 0; i--) {
    if (sentenceDelimiters.contains(lineText[i])) {
      if (textStartsWithTitle(lineText, titles, i))
        continue;
      let offset = 1;
      while (lineText[i + offset] === " " && offset < pos - lineStart - 1) {
        offset += 1;
      }
      while (extraCharacters.contains(lineText[i + offset]) && sentenceDelimiters.contains(lineText[i + offset - 1]) && offset < pos - lineStart - 1) {
        offset += 1;
      }
      start = i + offset;
      break;
    }
  }
  if (start == -1)
    start = 0;
  let end = -1;
  for (let i = pos - lineStart; i < line.length; i++) {
    if (sentenceDelimiters.contains(lineText[i])) {
      if (textStartsWithTitle(lineText, titles, i))
        continue;
      let offset = 1;
      while (sentenceDelimiters.contains(lineText[i + offset]) && offset < line.length) {
        offset += 1;
      }
      while (extraCharacters.contains(lineText[i + offset]) && offset < line.length) {
        offset += 1;
      }
      end = i + offset;
      break;
    }
  }
  if (end != -1) {
    return { start: start + lineStart, end: end + lineStart };
  } else {
    return { start: start + lineStart, end: null };
  }
}
function getActiveSentenceDecos(view) {
  const widgets = [];
  const selection = view.state.selection.main;
  const pos = selection.from;
  const line = view.state.doc.lineAt(pos);
  let activeSentenceBounds = getActiveSentenceBounds(line, pos);
  if (activeSentenceBounds.end == null) {
    if (pos > line.from) {
      activeSentenceBounds = getActiveSentenceBounds(line, pos - 1);
    }
  }
  const start = activeSentenceBounds.start;
  let end = activeSentenceBounds.end;
  if (end == null)
    end = line.to;
  function addWidget(from, to, className) {
    widgets.push(import_view.Decoration.mark({
      inclusive: true,
      attributes: {},
      class: className
    }).range(from, to));
  }
  if (start != end) {
    addWidget(start, end, "active-sentence");
    if (line.from != start)
      addWidget(line.from, start, "active-paragraph");
    if (end != line.to)
      addWidget(end, line.to, "active-paragraph");
  } else {
    if (line.from != line.to)
      addWidget(line.from, line.to, "active-paragraph");
  }
  return import_view.Decoration.set(widgets, true);
}
var FocusActiveSentenceViewPlugin = import_view.ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = getActiveSentenceDecos(view);
    this.editorElement = view.contentDOM.parentElement;
  }
  update(update) {
    if (update.docChanged || update.selectionSet) {
      this.decorations = getActiveSentenceDecos(update.view);
      if (this.editorElement) {
        this.editorElement.addClass("focus-active-sentence");
      }
    }
  }
}, { decorations: (v) => v.decorations });
var scrollEventHandler = import_view.EditorView.domEventHandlers({
  scroll(event, view) {
    const editorElement = view.contentDOM.parentElement;
    if (editorElement) {
      editorElement.removeClass("focus-active-sentence");
    }
  }
});

// main.ts
var DEFAULT_SETTINGS = {
  sentenceDelimiters: ".!?",
  extraCharacters: "*\u201C\u201D\u2018\u2019",
  titles: `Mr.
Ms.
Mrs.`
};
var FocusActiveSentencePlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new FocusActiveSentenceSettingTab(this.app, this));
    this.registerEditorExtension(FocusActiveSentenceViewPlugin.extension);
    this.registerEditorExtension(scrollEventHandler);
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var FocusActiveSentenceSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Sentence delimiters").setDesc("Characters that mark the end of a sentence. Default: .!?").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.sentenceDelimiters).setValue(this.plugin.settings.sentenceDelimiters).onChange(async (value) => {
      this.plugin.settings.sentenceDelimiters = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Extra characters").setDesc("Characters that may follow the end of a sentence, and should be included as part of it. Default: *\u201C\u201D\u2018\u2019").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.extraCharacters).setValue(this.plugin.settings.extraCharacters).onChange(async (value) => {
      this.plugin.settings.extraCharacters = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Titles").setDesc('A list of titles ending in a period, e.g. "Mr.", "Ms.", "Mrs.", separated by new lines. Ensures that e.g. "Mr." is not mistakenly identified as the end of a sentence.').addTextArea((text) => text.setPlaceholder(DEFAULT_SETTINGS.titles).setValue(this.plugin.settings.titles).onChange(async (value) => {
      this.plugin.settings.titles = value;
      await this.plugin.saveSettings();
    }));
  }
};
